% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nlsur.R
\name{nlsur}
\alias{nlsur}
\title{Fitting Iterative Feasible Non-Linear Seemingly Unrelated Regression Model}
\usage{
nlsur(eqns, data, startvalues, type = NULL, S = NULL, trace = FALSE,
  robust = FALSE, stata = TRUE, qrsolve = FALSE, weights, MASS = FALSE,
  maxiter = 1000, val = 0, tol = 1e-07, eps = 1e-05,
  ifgnlseps = 1e-10, tau = 0.001, initial = FALSE, multicores)
}
\arguments{
\item{eqns}{is a list object containing the model as formula. This list can
handle contain only a single equations (although in this case nls() might be
a better coice) or a system of equations.}

\item{data}{an (optional) data frame containing the variables that will be
evaluated in the formula.}

\item{startvalues}{initial values for the parameters to be estimated.}

\item{type}{can be 1 Nonlinear Least Squares (NLS), 2 Feasible Generalised
NLS (FGNLS) or 3 Iterative FGNLS (IFGNLS) or the respective abbrevations in
character form.}

\item{S}{is a weight matrix used for evaluation. If no weight matrix is
provided the identity matrix I will be used.}

\item{trace}{logical wheather or not SSR information should be printed.
Default is FALSE.}

\item{robust}{logical if true robust standard errors are estimated.}

\item{stata}{is a logical. If TRUE for nls a second evaluation will be run.
Stata does this by default. For this second run Stata replaces the diagonal
of the I matrix with the coefficients.}

\item{qrsolve}{logical}

\item{weights}{Additional weight vector.}

\item{MASS}{is a logical wheather the MASS::lm.gls() function should be used
for weighted Regression. This can cause sever RAM usage as the weight matrix
tend to be huge (n-equations * n-rows).}

\item{maxiter}{Maximum number of iterations.}

\item{val}{If no start values supplied, create them with this start value.
Default is 0.}

\item{tol}{qr.solves tolerance for detecting linear dependencies.}

\item{eps}{the epislon used for convergence in nlsur(). Default is 1e-5.}

\item{ifgnlseps}{is epislon for ifgnls(). Default is 1e-10.}

\item{tau}{is another convergence variable. Default is 1e-3.}

\item{initial}{logical value to define if rankMatrix is calculated every
iteration of nlsur.}

\item{multicores}{number of cores used for parallel mcl-/mcmapply if no value
is set this defaults to n-1.}
}
\value{
The function returns a list object of class nlsur. The list includes:
\describe{
  \item{coefficients:}{estimated coefficients}
  \item{residuals:}{residuals}
  \item{xi:}{residuals of each equation in a single list}
  \item{eqnames:}{list of equation names}
  \item{sigma:}{the weight matrix}
  \item{ssr:}{Residual sum of squares}
  \item{lhs:}{Left hand side of the evaluated model}
  \item{rhs:}{Right hand side of the evaluated model}
  \item{nlsur:}{model type. "NLS", "FGNLS" or "IFGNLS"}
  \item{se:}{standard errors}
  \item{t:}{t values}
  \item{covb:}{asymptotic covarince matrix}
  \item{zi:}{equation wise estimation results of SSR, MSE, RMSE, MAE, R2 and
Adj-R2. As well as n, k and df.}
  \item{model:}{equvation or system of equations as list containing
formulas}
}
}
\description{
\code{nlsur()} is used to fit nonlinear regression models. It can handle the
feasible and iterative feasible variants.
}
\details{
nlsur() is a wrapper around .nlsur(). The function was initialy
inspired by the Stata Corp Function nlsur.
Nlsur estimates a nonlinear least squares demand system. With nls, fgnls or
ifgnls which is equivalent to Maximum Likelihood estimation.
Nonlinear least squares requires start values and nlsur requires a weighting
matrix for the demand system. If no weight matrix is provided, nlsur will use
the identity matrix I. If type = 1 or type = "nls" is added, nlsur will use
the matrix for an initial estimation, once the estimation is done, it will
swap the diagonal with the estimated results.

Most robust regression estimates shall be returned with both qrsolve and MASS
TRUE, but memory consumtion is largest this way. If MASS is FALSE a memory
efficent RcppArmadillo solution is used for fgnls and ifgnls. If qrsolve is
FALSE as well, only the Armadillo function is used.

If \code{robust} is selected Whites HC0 is used to caclulate
Heteroscedasticity Robust Standard Errors.

If \code{initial} is TRUE rankMatrix will be calculated every iteration of
nlsur. Meaning for nls at least once, for fgnls at least twice and for ifgnls
at least three times. This adds a lot of overhead, since rankMatrix is used
to calculate k. To assure that k does not change this can be set to TRUE.

Nlsur has methods for the generic functions \link{coef}, \link{confint},
\link{deviance}, \link{df.residual}, \link{fitted}, \link{predict},
\link{print}, \link{residuals}, \link{summary} and \link{vcov}.
}
\examples{
\dontrun{
# Greene Example 10.3
library(nlsur)

url <- "http://www.stern.nyu.edu/~wgreene/Text/Edition7/TableF10-2.txt"
dd <- read.table(url, header = T)

names(dd) <- c("Year", "Cost", "Sk", "Sl", "Se", "Sm", "Pk", "Pl", "Pe", "Pm")


eqns <- list( Sk ~ bk + dkk * log(Pk/Pm) + dkl * log(Pl/Pm) + dke * log(Pe/Pm),
              Sl ~ bl + dkl * log(Pk/Pm) + dll * log(Pl/Pm) + dle * log(Pe/Pm),
              Se ~ be + dke * log(Pk/Pm) + dle * log(Pl/Pm) + dee * log(Pe/Pm))

strtvls <- c(be = 0, bk = 0, bl = 0,
             dkk = 0, dkl = 0, dke = 0,
             dll = 0, dle = 0, dee = 0)


erg <- nlsur(eqns = eqns, data = dd, startvalues = strtvls, type = 2,
             trace = TRUE, eps = 1e-10)

erg
}
}
\references{
Gallant, A. Ronald (1987): Nonlinear Statistical Models.
 Wiley: New York
}
\seealso{
\link{nls}
}
